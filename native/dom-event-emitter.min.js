(a=>{"use strict";function b(){const a=new Uint8Array(16);for(let b=0;16>b;b++)a[b]=0|256*Math.random();let b="";for(let c,d=0;3>d;d++)c=5*d,b+=g[a[c]>>3],b+=g[(7&a[c])<<2|a[c+1]>>6],b+=g[(62&a[c+1])>>1],b+=g[(1&a[c+1])<<4|a[c+2]>>4],b+=g[(15&a[c+2])<<1|a[c+3]>>7],b+=g[(124&a[c+3])>>2],b+=g[(3&a[c+3])<<3|a[c+4]>>5],b+=g[31&a[c+4]];return b+=g[a[15]>>3],b+=g[(7&a[16])<<2],b}function c(a,b,c){if("function"!=typeof c)throw new TypeError("Given listener should be a function");const d=function(...f){const{_event_queue:g,_handle_promise:h}=e.get(this),i=b.toString(),j=g[i]=g[i]||[];let k=j.indexOf(d);return h?Promise.resolve(c.call(a,...f)).then(()=>{0<=k&&j.splice(k,1)}):(c.call(a,...f),void(0<=k&&j.splice(k,1)))};return d}const d=a.DOMEventEmitter,e=new WeakMap;class f{constructor(){const a={};e.set(this,a),a._event_queue=[]}addListener(a,b){if("function"!=typeof b)throw new TypeError("Given listener should be a function");const{_event_queue:c}=e.get(this),d=a.toString(),f=c[d]=c[d]||[];return f.push(b),this}on(a,b){let c=`${a}`.trim();if(0<c.length){c=c.split(",");for(let a of c)this.addListener(a.trim(),b)}return this}once(a,b){let d=`${a}`.trim();return 0<d.length&&([a]=d.split(",")),this.addListener(a,c(this,a,b))}removeListener(a,b){const{_event_queue:c}=e.get(this),d=a.toString(),f=c[d];if(f)for(let a;0<=(a=f.indexOf(b));)f.splice(a,1);return this}removeAllListeners(a){const b=e.get(this),c=a.toString();return delete b._event_queue[c],this}off(a,b){let c=`${a}`.trim();if(0===c.length)return this;if(c=c.split(","),1===arguments.length){for(let a of c)this.removeAllListeners(a.trim());return this}for(let d of c)this.removeListener(d.trim(),b);return this}dispatch(a,...c){const{_event_queue:d}=e.get(this),f=a.toString(),g=b(),h=d[f];if(Array.isArray(h)){let a=!0;const b={};Object.defineProperties(b,{_id:{value:g,enumerable:!0},type:{value:f,enumerable:!0},timestamp:{value:Date.now(),enumerable:!0},stopPropagation:{value:()=>{a=!1},enumerable:!0}});for(let d of h)if(d.call(this,b,...c),!a)break}return this}async dispatchAwait(a,...c){const{_event_queue:d}=e.get(this),f=a.toString(),g=b(),h=d[f];if(Array.isArray(h)){let a=!0;const b={};Object.defineProperties(b,{_id:{value:g,enumerable:!0},type:{value:f,enumerable:!0},timestamp:{value:Date.now(),enumerable:!0},stopPropagation:{value:()=>{a=!1},enumerable:!0}});for(let d of h)if(await d.call(this,b,...c),!a)break}return this}emit(a,...b){return this.dispatch(a,...b)}emitAwait(a,...b){return this.dispatchAwait(a,...b)}listeners(a){const{_event_queue:b}=e.get(this),c=a.toString();return(b[c]||[]).slice(0)}get events(){const{_event_queue:a}=e.get(this),b=[];for(let c in a)a.hasOwnProperty(c)&&(0===a[c].length||b.push(c));return b}set events(a){throw new TypeError("Cannot assign to read only property 'events' of <DOMEventEmitter>")}static get version(){return"1.0.0"}static set version(a){throw new TypeError("Cannot assign to read only property 'version' of <DOMEventEmitter>")}static noConflict(){return d&&(a.DOMEventEmitter=d),a.DOMEventEmitter}}const g=["0","1","2","3","4","5","6","7","8","9","A","B","C","D","E","F","G","H","I","J","K","L","M","N","O","P","Q","R","S","T","U","V"];a.DOMEventEmitter=f})("undefined"==typeof window?"undefined"==typeof module?{}:module.exports:window);